<!-- TOC -->

- [1. Easy Problem: Merge Sorted Array](#1-easy-problem-merge-sorted-array)
- [2. Solution](#2-solution)
  - [2.1. Approach: Quick Sort](#21-approach-quick-sort)
    - [2.1.1. Complexity Analysis](#211-complexity-analysis)

<!-- /TOC -->

## 1. Easy Problem: Merge Sorted Array
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

**Note:**

- The number of elements initialized in nums1 and nums2 are m and n respectively.
- You may assume that nums1 has enough space (size that is **equal** to m + n) to hold additional elements from nums2.

**Example:**

>Input:
>nums1 = [1,2,3,0,0,0], m = 3
>nums2 = [2,5,6],       n = 3
>
>Output: [1,2,2,3,5,6]
 

**Constraints:**

> - -10^9 <= nums1[i], nums2[i] <= 10^9
> - nums1.length == m + n
> - nums2.length == n



## 2. Solution
- cuz this problem is meaningless, so you can slove it casually

### 2.1. Approach: Quick Sort
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //merge two arrays
        if (m == 0 && n == 0) {
            return;
        } else if (m == 0 && n != 0) {
            for (int i = 0; i < n; i++) {
                nums1[i] = nums2[i];
            }
        } else {
            for (int i = 0; i < n; i++) {
                nums1[m + i] = nums2[i];
            }
        }
        //use quick sort to deal with it
        sort(nums1, 0, m + n - 1);
    }

    public static void sort(int arr[], int low, int high) {
        int start = low;
        int end = high;
        int key = arr[low];
        while (end > start) {
            while (end > start && arr[end] >= key) {
                end--;
            }
            if (arr[end] <= key) {
                int temp = arr[end];
                arr[end] = arr[start];
                arr[start] = temp;
            }
            while (end > start && arr[start] <= key) {
                start++;
            }
            if (arr[start] >= key) {
                int temp = arr[start];
                arr[start] = arr[end];
                arr[end] = temp;
            }
        }
        if (start > low) {
            sort(arr, low, start - 1);
        }
        if (end < high) {
            sort(arr, end + 1, high);
        }
    }
}

```

#### 2.1.1. Complexity Analysis
- Time Complexity: O(nlog<sub>2</sub>n) ~ O(n<sup>2</sup>)
- Space Complexity: O(1)